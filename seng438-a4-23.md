SENG 438 - Software Testing, Reliability, and Quality

Lab Report #4 - Mutation and GUI Testing

| Group \#:      |  23  |
| -------------- | --- |
| Student Names: |     |
| M Munem Morhsed |     |
| Himel Paul |     |
| SM Wahid Chowdhury |     |
| Maliha Chowdhury Adrita |     |
| Kosy Onyejemezi |     |

# 1 Introduction

This lab report presents our work on two major aspects of software testing: Mutation Testing and GUI Testing. In Part 1, we applied mutation testing to evaluate the effectiveness of our test suites using Pitest on the JFreeChart codebase. In Part 2, we automated GUI tests using Selenium IDE for selected functionalities on a chosen website and compared Selenium with Sikulix.

# Analysis of Mutants of the Range class 


# All the statistics and the mutation score for each test classs

Range Original Mutation Score (%)

DataUtilities Original Mutation Score (%)

# Improved statistics

# A discussion of how the mutation score improved

To improve the mutation scores for both Range and DataUtilities, we analyzed the surviving mutants generated by Pitest and identified untested conditions, edge cases, and boundary values. In particular, we noticed that some mutants survived due to missing test coverage for null inputs, extreme values, and certain combinations of method parameters. Based on this analysis, we wrote additional test cases that explicitly targeted these untested paths and behaviors. For example, in the RangeTest, we added tests for overlapping and non-overlapping range combinations, and in DataUtilitiesTest, we included cases with empty arrays, negative numbers, and null references. These additions allowed us to increase the mutation score by covering logical branches and code paths that were previously untested, leading to a measurable improvement in test suite quality.

# A discussion on the advantages and disadvantages of mutation testing

Mutation testing provides a deeper measure of test suite effectiveness by introducing small faults (mutants) into the code and checking whether existing tests can detect them. One major advantage is that it uncovers inadequacies in the test suite that traditional code coverage metrics might miss. It encourages writing more robust tests by exposing edge cases and subtle logic flaws. Additionally, it can reveal unreachable or untested parts of the code, helping developers improve test coverage in a meaningful way. However, mutation testing also has several drawbacks. It can be computationally expensive, especially for large codebases, as it involves running tests against many mutated versions of the code. The process can be time-consuming and may produce a large number of mutants, including equivalent ones that cannot be killed, which can skew mutation scores and require manual investigation. Despite its limitations, mutation testing remains a powerful technique for improving test suite quality when used thoughtfully.

# GUI Testing

