SENG 438 - Software Testing, Reliability, and Quality

Lab Report #4 - Mutation and GUI Testing

| Group \#:      |  23  |
| -------------- | --- |
| Student Names: |     |
| M Munem Morhsed |     |
| Himel Paul |     |
| SM Wahid Chowdhury |     |
| Maliha Chowdhury Adrita |     |
| Kosy Onyejemezi |     |

# 1 Introduction

This lab report presents our work on two major aspects of software testing: Mutation Testing and GUI Testing. In Part 1, we applied mutation testing to evaluate the effectiveness of our test suites using Pitest on the JFreeChart codebase. In Part 2, we automated GUI tests using Selenium IDE for selected functionalities on a chosen website and compared Selenium with Sikulix.

# Analysis of Mutants of the Range class 


# All the statistics and the mutation score for each test classs

Range Original Mutation Score (%)

DataUtilities Original Mutation Score (%)

# Improved statistics

# A discussion of how the mutation score improved

To improve the mutation scores for both Range and DataUtilities, we analyzed the surviving mutants generated by Pitest and identified untested conditions, edge cases, and boundary values. In particular, we noticed that some mutants survived due to missing test coverage for null inputs, extreme values, and certain combinations of method parameters. Based on this analysis, we wrote additional test cases that explicitly targeted these untested paths and behaviors. For example, in the RangeTest, we added tests for overlapping and non-overlapping range combinations, and in DataUtilitiesTest, we included cases with empty arrays, negative numbers, and null references. These additions allowed us to increase the mutation score by covering logical branches and code paths that were previously untested, leading to a measurable improvement in test suite quality.

# A discussion on the advantages and disadvantages of mutation testing

Mutation testing provides a deeper measure of test suite effectiveness by introducing small faults (mutants) into the code and checking whether existing tests can detect them. One major advantage is that it uncovers inadequacies in the test suite that traditional code coverage metrics might miss. It encourages writing more robust tests by exposing edge cases and subtle logic flaws. Additionally, it can reveal unreachable or untested parts of the code, helping developers improve test coverage in a meaningful way. However, mutation testing also has several drawbacks. It can be computationally expensive, especially for large codebases, as it involves running tests against many mutated versions of the code. The process can be time-consuming and may produce a large number of mutants, including equivalent ones that cannot be killed, which can skew mutation scores and require manual investigation. Despite its limitations, mutation testing remains a powerful technique for improving test suite quality when used thoughtfully.

# GUI Testing

# Correctness and completeness of the Recorded test cases (at least 2 per group member)

# Explain your test case design process

# Use of automated verification points in each script

# Use different test data per test

To ensure thorough coverage and realistic simulation of user behavior, we used different test data and user interactions across various test cases. We selected multiple websites provided in the assignment—such as Home Depot, Gap Canada, and Real Canadian Superstore—and performed distinct tasks on each. For example, on the Real Canadian Superstore site, we created test cases that involved searching for products and adding them to the cart, while for 


# Discuss advantages and disadvantages of Selenium vs. Sikulix

Selenium and Sikulix are both automation tools but serve different purposes and have distinct strengths. Selenium is specifically designed for web application testing and interacts directly with HTML elements, making it reliable and efficient for validating web-based workflows. It supports automated verification, cross-browser testing, and integrates well with modern CI/CD pipelines. However, it is limited to web environments and can become fragile when dealing with dynamic or complex page structures. On the other hand, Sikulix uses image recognition to automate any GUI, whether web or desktop, by visually identifying elements on the screen. This makes it suitable for applications that Selenium cannot test, such as legacy software or graphical interfaces without accessible HTML. Despite its flexibility, Sikulix is more sensitive to screen resolution and layout changes, which can lead to brittle tests. It also lacks advanced verification features and is generally slower and harder to maintain for large-scale automation. Overall, Selenium is the better choice for structured, web-based applications, while Sikulix offers versatility at the cost of robustness and maintainability.
